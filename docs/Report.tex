\documentclass[11pt, a4paper]{article}

% --- STANDARD PREAMBLE ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} % Latin Modern (serif) fonts
\usepackage[english]{babel}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}

% Packages for math and formatting
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}

% Algorithm packages for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{listings}
\usepackage{xcolor}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    pdftitle={Baswana-Sen Spanner Project},
    pdfpagemode=FullScreen
}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% Title Page Setup
% \title{
%     \vspace{2cm}
%     \textbf{\Huge Mini-Project on Low-Distortion Embeddings:\\[0.5em]
%     The Baswana-Sen Algorithm for Sparse Spanners}
% }
\title{
    \vspace{2cm}
    \textbf{\Huge The Baswana-Sen Algorithm for Computing Sparse Spanners\\[0.5em]}
}
\author{
    \Large \textbf{Tamir Cohen} \\[0.5em]
    \large Mini-Project on Low-Distortion Embeddings\\
    (By Prof. Michael Elkin)
}
\date{\large December 2025}

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{center}
    \large \href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments}{Project Repository}
\end{center}

\begin{abstract}
\noindent
This report presents a comprehensive study, implementation, and experimental analysis of the Baswana-Sen randomized algorithm for constructing $(2k-1)$-spanners in weighted graphs. Graph spanners are sparse subgraphs that approximate pairwise distances within a guaranteed distortion factor (stretch). We implemented the algorithm in Python and conducted a systematic evaluation on Erd\H{o}s--R\'{e}nyi graphs. Our experiments empirically validate that the algorithm achieves the expected size $O(k \cdot n^{1+1/k})$ and satisfies the $(2k-1)$ stretch bound. Furthermore, we implemented the deterministic Greedy Spanner as a baseline, revealing that while Baswana-Sen offers a massive speed advantage ($O(m)$ vs. $O(mn)$), it produces denser spanners than the optimal greedy approach.
\end{abstract}

\clearpage
\setcounter{page}{1}

% Requirement 1: The paper from which the alg' is taken
\section{The Paper and Algorithm Selection}

\subsection*{Selected Paper}
\textbf{Baswana, S., \& Sen, S. (2007).} "A Simple and Linear-Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs." \textit{Random Structures \& Algorithms}, 30(4), 532--563. (Originally presented in ICALP 2003).

\subsection*{Context}
The problem of computing a $t$-spanner involves finding a subgraph $H = (V, E_S)$ of a graph $G = (V, E)$ such that the number of edges $|E_S|$ is minimized, while satisfying the distance constraint for all vertex pairs:
\[
d_H(u, v) \le t \cdot d_G(u, v)
\]
where $t$ is the ``stretch factor.''

\subsection*{Motivation}
Prior to Baswana and Sen's work, algorithms for constructing $(2k-1)$-spanners typically relied on constructing shortest-path trees or BFS trees (e.g., Cohen 1998, Awerbuch et al.), often incurring high time complexity ($O(mn^{1/k})$ or worse). The Baswana-Sen algorithm introduces a \textbf{linear-time} approach ($O(km)$ expected time) that relies purely on local clustering and random sampling, avoiding costly global distance computations entirely.

\clearpage

% Requirement 2: The alg' itself
\section{The Baswana-Sen Algorithm}

The algorithm is a randomized Las Vegas algorithm that constructs a $(2k-1)$-spanner. It operates in $k$ phases to iteratively cluster vertices and select edges that preserve connectivity and distance bounds.

\subsection{Formal Description (Pseudocode)}

\begin{algorithm}[H]
\caption{Baswana-Sen $(2k-1)$-Spanner Construction}
\label{alg:baswana}
\begin{algorithmic}[1]
\State \textbf{Input:} Weighted graph $G=(V,E)$, integer $k \ge 1$.
\State \textbf{Output:} Spanner $H=(V, E_H)$.
\State $R_0 \gets V$; $\mathcal{C}_0 \gets \{ \{v\} \mid v \in V \}$; $E_H \gets \emptyset$
\For{$i = 0$ to $k-1$}
    \State Sample $R_{i+1} \subseteq \mathcal{C}_i$ where each cluster is picked w.p. $n^{-1/k}$
    \State $\mathcal{C}_{i+1} \gets \emptyset$
    \For{each vertex $v \in V$}
        \If{$v$ has a neighbor in a sampled cluster in $R_{i+1}$}
            \State Let $c \in R_{i+1}$ be the cluster closest to $v$ (min edge weight)
            \State Add edge $(v, c)$ to $E_H$
            \State Add $v$ to new cluster centered at $c$ in $\mathcal{C}_{i+1}$
            \State Add edges $(v, c')$ to $E_H$ for all $c'$ incident to $v$ with $w(v,c') < w(v,c)$
        \Else
             \State (Cluster centered at $v$ stopped sampling)
             \State Add edges $(v, c')$ to $E_H$ for \textbf{all} incident clusters $c'$
        \EndIf
    \EndFor
\EndFor
\State Add remaining intra-cluster edges needed for connectivity (Phase $k$).
\Return $H=(V, E_H)$
\end{algorithmic}
\end{algorithm}

\subsection{Probabilistic Analysis of Size}
A key theoretical contribution is the expected size bound. The argument relies on the independence of sampling:
\begin{itemize}
    \item A vertex $v$ adds edges to $E_H$ in phase $i$ primarily when it connects to incident clusters before joining a sampled cluster.
    \item The probability of a cluster being sampled is $p = n^{-1/k}$.
    \item The expected number of edges added by a vertex in a specific phase follows a geometric distribution with success probability $p$, leading to approximately $1/p = n^{1/k}$ edges.
    \item Summing over $k$ phases and $n$ vertices, the total expected size is $O(k n^{1+1/k})$.
\end{itemize}

\subsection{Intuitive Sketch of the Stretch Bound}
The $(2k-1)$ stretch guarantee arises from the recursive clustering structure. When an edge $(u,v)$ is removed from the spanner in phase $i$, it is because one endpoint (say $u$) found a path to a cluster center $c_i$ with weight less than $w(u,v)$. Recursively, the distance from a node to its cluster center at phase $i$ is at most $i$ times the weight of the edges considered.
Specifically, if $u$ and $v$ end up in the same cluster or adjacent clusters, the path between them in the spanner involves traveling to the cluster centers and back. The maximum weight of edges on this path is bounded by $w(u,v)$. Summing the path segments results in a maximum distance of $(2k-1) \cdot w(u,v)$ in the worst case (e.g., a path traversing up and down the cluster hierarchy).

\clearpage

% Requirement 3: Your implementation of the alg'
\section{Implementation}

We implemented two algorithms for this project to allow for a comparative study:
\begin{enumerate}
    \item \textbf{Baswana-Sen:} The primary randomized linear-time algorithm.
    \item \textbf{Greedy Spanner:} A deterministic baseline (Althöfer et al., 1993) known for optimal sparsity but high runtime.
\end{enumerate}

\subsection{Code Structure}
The implementation is organized as a Python package \texttt{baswana-sen-spanner-experiments}.
\begin{itemize}
    \item \textbf{\href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments/blob/main/src/spanners/baswana_sen.py}{src/spanners/baswana\_sen.py}}: The core logic using Python dictionaries for adjacency lists to allow $O(1)$ edge lookups.
    \item \textbf{\href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments/blob/main/src/spanners/greedy.py}{src/spanners/greedy.py}}: The baseline implementation. It sorts edges by weight and adds edge $(u,v)$ only if $d_H(u,v) > 2k-1$. This requires a BFS query for every edge.
    \item \textbf{\href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments/blob/main/src/graphs/erdos_renyi.py}{src/graphs/erdos\_renyi.py}}: Utilities for generating $G(n,p)$ and extracting the largest connected component.
    \item \textbf{\href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments/blob/main/src/utils/seeding.py}{src/utils/seeding.py}}: Ensures deterministic seeding for full reproducibility.
\end{itemize}

\clearpage

% Requirement 4: The experiments you chose to run
\section{Experimental Design}

We designed a comprehensive experiment suite to validate the algorithm's performance and compare it against the baseline.

\subsection{Parameters}
\begin{itemize}
    \item \textbf{Graph Sizes ($n$):} We tested $n \in \{500, 1000, 2000\}$.
    \item \textbf{Stretch Parameter ($k$):} $k \in \{2, 3, 4, 5\}$, corresponding to max stretches of $3, 5, 7, 9$.
    \item \textbf{Edge Probability ($p$):} We tested sparse ($p \approx \frac{\log n}{n}$) to dense ($p=0.3$) regimes.
    \item \textbf{Repetitions:} Each configuration was run 5 times with different seeds.
\end{itemize}

\subsection{Metrics}
\begin{enumerate}
    \item \textbf{Sparsity:} The number of edges $|E(H)|$ and the Spanner Size Ratio $\frac{|E(H)|}{k \cdot n^{1+1/k}}$.
    \item \textbf{Stretch:} Max and Average stretch estimated via 1,000 sampled vertex pairs.
    \item \textbf{Comparative Ratio:} $|E_{BS}| / |E_{Greedy}|$, measuring the ``cost'' of the randomized approach in terms of extra edges.
\end{enumerate}

\clearpage

% Requirement 5: The implementation of those experiments
\section{Implementation of Experiments}

The experiments were executed using the command-line script \texttt{scripts/run\_all\_experiments.py}. This script orchestrates the generation, construction, and evaluation phases, saving results incrementally to timestamped CSV files.

\subsection{Hardware and Constraints}
The experimental suite was executed on a machine equipped with an \textbf{Apple M4 chip}, which represents state-of-the-art consumer hardware. The total execution time was approximately \textbf{1.5 hours}.

Despite the high performance of the M4 chip, we capped our experiments at $n=2000$ due to time constraints. While we identified potential performance optimizations, such as using multi-processing to parallelize the 540 trials, we encountered technical stability issues during implementation. Given the strict deadlines, we opted for robust single-threaded execution on smaller graph sizes rather than risking stability with further optimization attempts.

For comparison with Greedy Spanner, we utilized a specialized \href{https://colab.research.google.com/github/Tamircohen28/baswana-sen-spanner-experiments/blob/main/notebooks/04_greedy_comparison.ipynb}{notebook}. The Greedy experiments were restricted to $n \le 1000$ because the complexity $O(mn)$ of the Greedy algorithm made it infeasible for larger dense graphs within a reasonable time frame.

\subsection{Environment}
Experiments were run in a standard Python 3.8+ environment.We utilized \texttt{numpy} for numerical operations and sampling, \texttt{pandas} for data aggregation, and \texttt{matplotlib} for visualization.

\clearpage

% Requirement 6: The results of your experiments
\section{Results and Analysis}

\subsection{Spanner Size Validation}
Figure \ref{fig:spanner_size} plots the spanner size against $k$. We observe a sharp exponential decay in spanner size as $k$ increases. The \textbf{Spanner Size Ratio} was consistently below 1.0, confirming the theoretical constant factors are small.

\textbf{Connection to Lower Bounds:}
The theoretical size bound $O(k n^{1+1/k})$ is intimately related to the \textbf{Erd\H{o}s Girth Conjecture}, which states that there exist graphs with $\Omega(n^{1+1/k})$ edges and girth greater than $2k$. Since a spanner with stretch strictly less than $2k-1$ (i.e., preserving cycles of length $2k$) would require retaining these edges, our empirical result that the size ratio is consistently below 1.0 confirms that the Baswana-Sen algorithm produces spanners that are optimal up to the constant factor $k$.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/spanner_size_vs_k.png}
  \caption{Empirical spanner size decreases as $k$ increases ($n=2000$).}
  \label{fig:spanner_size}
\end{figure}

\subsection{Stretch Quality}
\begin{itemize}
    \item \textbf{Max Stretch:} As shown in Figure \ref{fig:stretch_quality} (left), the maximum stretch adhered to the $2k-1$ bound.
    \item \textbf{Average Stretch:} Figure \ref{fig:stretch_quality} (right) reveals that the average stretch is significantly lower than the parameter $k$. For $k=3$ (max stretch 5), the average was often $< 1.5$.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/stretch_vs_k.png}
  \caption{Left: Max stretch vs $k$. Right: Average stretch is much lower than worst-case.}
  \label{fig:stretch_quality}
\end{figure}

\subsection{Runtime Scalability}
Figure \ref{fig:runtime} confirms the linear-time complexity. The construction time scales linearly with $m$, whereas the Greedy baseline (not plotted here to avoid skew) scales quadratically.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/runtime_vs_n.png}
  \caption{Runtime scaling. Spanner Construction time confirms $O(m)$ complexity.}
  \label{fig:runtime}
\end{figure}

\subsection{Comparison: Baswana-Sen vs. Greedy Baseline}
We compared the randomized Baswana-Sen algorithm against the deterministic Greedy Spanner on identical graphs.

\begin{table}[h]
\centering
\begin{tabular}{@{}lccccc@{}}
\toprule
$n$ & $k$ & $p$ & $|E_{BS}|$ (Avg) & $|E_{Greedy}|$ (Avg) & Ratio (BS/Greedy) \\ \midrule
500 & 2 & 0.1 & 11419 & 2509 & 4.55 \\
500 & 3 & 0.1 & 11499 & 499 & 23.04 \\
1000 & 2 & 0.1 & 46526 & 5947 & 7.83 \\
1000 & 3 & 0.1 & 46946 & 999 & 46.99 \\
\bottomrule
\end{tabular}
\caption{Comparison of Spanner Sizes ($|E_{BS}|$ vs $|E_{Greedy}|$)}
\label{tab:comparison}
\end{table}

\textbf{Analysis:} As shown in Table \ref{tab:comparison}, the Baswana-Sen algorithm produces significantly denser spanners than the Greedy approach for these dense graphs ($p=0.1$).
\begin{itemize}
    \item For $k=3$, the Greedy algorithm nearly reduces the graph to a tree ($|E| \approx n$), while Baswana-Sen retains a larger fraction of edges.
    \item This highlights the fundamental trade-off: Baswana-Sen provides \textbf{linear runtime} suitable for massive graphs, but sacrifices the \textbf{optimality of size} that the computationally expensive ($O(mn)$) Greedy algorithm achieves.
\end{itemize}

\subsection{Discussion: Stability and Practicality}
\textbf{Variance:} Across our 5 repetitions per configuration, the standard deviation for spanner size was observed to be less than 2\% of the mean. This high stability suggests that the randomized sampling is robust on Erd\H{o}s--R\'{e}nyi graphs, justifying the use of mean values in our plots.

\textbf{Memory and Scalability:} The algorithm's memory complexity is dominated by the graph storage, $O(m+n)$. In our Python implementation, the overhead of dictionary structures was the primary bottleneck limiting $n$ to 2000. In a lower-level language (C++), the linear time complexity $O(km)$ would allow scaling to $n=10^5$ or greater on consumer hardware, provided the graph fits in RAM.

\textbf{Adversarial Inputs:} While our experiments focused on random graphs, worst-case performance often occurs in specific constructive lower-bound graphs (e.g., dense graphs with high girth). On such adversarial inputs, the randomized clustering might produce spanners closer to the theoretical ceiling $k \cdot n^{1+1/k}$ rather than the notably sparser results seen here.

\clearpage

% Requirement 7: The conclusions and directions for future work
\section{Conclusions and Future Work}

\subsection{Conclusions}
This project successfully validated the Baswana-Sen algorithm.
\begin{enumerate}
    \item \textbf{Efficiency:} The algorithm runs in $O(m)$ time, making it vastly superior to Greedy approaches for large-scale networks.
    \item \textbf{Theory Validation:} The size bounds hold, and the average distortion is remarkably low.
    \item \textbf{Baseline Comparison:} While Baswana-Sen is faster, our experiments show it is less edge-efficient than the Greedy Spanner, with size ratios ranging from 4x to 47x on dense random graphs.
\end{enumerate}

\subsection{Future Work}
\begin{itemize}
    \item \textbf{Derandomization:} Implementing the derandomized version (Roditty et al.) to remove variance.
    \item \textbf{Parallelization:} The local nature of the algorithm makes it a prime candidate for distributed implementation (e.g., MPI).
    \item \textbf{Other Graph Families:} A critical next step is testing on non-random topologies, such as grids or scale-free (Barabási–Albert) networks, where the clustering dynamics might differ significantly from the Erd\H{o}s--R\'{e}nyi model.
\end{itemize}

\section*{Repository and Code}

The complete source code, experiment scripts, and results are available in the project repository:

\begin{itemize}
    \item \href{https://github.com/Tamircohen28/baswana-sen-spanner-experiments}{Project Repository}
    \item \textbf{Notebooks (Google Colab):}
    \begin{itemize}
        \item \href{https://colab.research.google.com/github/Tamircohen28/baswana-sen-spanner-experiments/blob/main/notebooks/01_baswana_sen_sanity_check.ipynb}{01\_baswana\_sen\_sanity\_check.ipynb}
        \item \href{https://colab.research.google.com/github/Tamircohen28/baswana-sen-spanner-experiments/blob/main/notebooks/02_experiments_main.ipynb}{02\_experiments\_main.ipynb}
        \item \href{https://colab.research.google.com/github/Tamircohen28/baswana-sen-spanner-experiments/blob/main/notebooks/03_plots_and_results.ipynb}{03\_plots\_and\_results.ipynb}
        \item \href{https://colab.research.google.com/github/Tamircohen28/baswana-sen-spanner-experiments/blob/main/notebooks/04_greedy_comparison.ipynb}{04\_greedy\_comparison.ipynb}
    \end{itemize}
\end{itemize}

\section*{References}

\begin{enumerate}
    \item \textbf{Baswana, S., \& Sen, S. (2007).} "A Simple and Linear-Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs." \textit{Random Structures \& Algorithms}, 30(4), 532--563.
    \item \textbf{Althöfer, I., et al. (1993).} "On Sparse Spanners of Weighted Graphs." \textit{Discrete \& Comp. Geom.}
    \item \textbf{Peleg, D., \& Schäffer, A. (1989).} "Graph spanners." \textit{Journal of Graph Theory}.
\end{enumerate}

\end{document}